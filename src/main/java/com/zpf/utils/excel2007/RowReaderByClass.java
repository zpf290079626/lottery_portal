package com.zpf.utils.excel2007;import com.zpf.utils.ObjectCoverUtil;import com.zpf.utils.excel2007.annotation.ExcelField;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import org.xml.sax.SAXException;//根据传入注解的class读取excel，根据注解自动校验模板是否正确public class RowReaderByClass implements IRowReader {    private List<Object> readInfo = new ArrayList<Object>(); // 将各行数据放到    private boolean templateCheck = false;    private int colCount = 0; // 列数    private List<ExcelField> excelAnnotationList = null;    private Class<?> cls;    private Map<Integer, Method> methods = null;    RowReaderByClass(Class<?> cls) throws InstantiationException, IllegalAccessException {        this.cls = cls;        excelAnnotationList = this.getFieldAnnotation(cls.newInstance());        colCount = this.getMaxIndexFromAnnotationList(excelAnnotationList) + 1; // 计算到读取的列数        methods = this.initMethod();    }    /*     * 业务逻辑实现方法     *      * @see com.eprosun.util.excel.IRowReader#getRows(int, int, java.util.List)     */    @Override    public void getRows(int sheetIndex, int curRow, Map<Integer, String> rowDataMap) throws Exception {        // 校验模板        if (!this.templateCheck) { // 如果校验过，则不再校验            this.checkTemplate(excelAnnotationList, rowDataMap);            templateCheck = true;            return; // 首行模板不保存        }        if (curRow > MAX_ROW_COUNT) {            throw new SAXException("当前文件中最大行数已超过：" + MAX_ROW_COUNT + "请将文件分割为多个文件后再导入！");        }        // 补充空白行        for (int j = readInfo.size(); j < curRow - 2; j++) { // 表头不写入数据列表中            try {                readInfo.add(this.cls.newInstance());            }            catch (Exception e) {                throw new Exception(e.getMessage());            }        }        Object obj = this.cls.newInstance();        for (ExcelField excelField : excelAnnotationList) {            int index = excelField.index();            Method method = methods.get(index);            Class<?> fieldType = method.getParameterTypes()[0];            Object value = null;            value = ObjectCoverUtil.covert(rowDataMap.get(index), fieldType);            if (null != value) {                method.invoke(obj, value);            }        }        readInfo.add(obj);    }    @Override    public List<Object> getReadInfo() {        return readInfo;    }    @Override    public int getColCount() {        return this.colCount;    }    // 初始化method方法，并将method按照注解的index排序    private Map<Integer, Method> initMethod() {        Map<Integer, Method> methods = new HashMap<Integer, Method>();        Method[] ms = this.cls.getDeclaredMethods();        for (int i = 0; i < excelAnnotationList.size(); i++) {            String fieldName = excelAnnotationList.get(i).colName();            int index = excelAnnotationList.get(i).index();            for (Method me : ms) {                if (me.getName().equals("set" + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1, fieldName.length()))) {                    methods.put(index, me);                }            }        }        return methods;    }    // 获取bean的注解信息    private List<ExcelField> getFieldAnnotation(Object record) {        Field[] fields = record.getClass().getDeclaredFields();        List<ExcelField> cols = new ArrayList<ExcelField>();        for (Field field : fields) {            ExcelField excelField = field.getAnnotation(ExcelField.class);            if (null != excelField) {                cols.add(excelField);            }        }        return cols;    }    // 校验模板是否正确    private void checkTemplate(List<ExcelField> excelAnnotationList, Map<Integer, String> rowDataMap) throws Exception {        for (int i = 0; i < excelAnnotationList.size(); i++) {            int index = excelAnnotationList.get(i).index();            String name = excelAnnotationList.get(i).colDesc();            if (!name.equals(rowDataMap.get(index))) {                throw new Exception("文件模板错误，请重新下载");            }        }    }    @Override    public List<String> getRowHead() {        List<String> rowHead = new ArrayList<String>();        for (int i = 0; i < excelAnnotationList.size(); i++) {            for (ExcelField excelField : excelAnnotationList) {                rowHead.add(excelField.colName());                break;            }        }        return rowHead;    }    @Override    public List<?> getReadInfoByPage(int pageSize, int index) {        int rowCount = this.getRowCount() - 1;        int start = pageSize * (index - 1);        int end = pageSize * index;        if (end > rowCount) {            end = rowCount;        }        List<Object> readInfo = new ArrayList<Object>();        for (int i = start; i < end; i++) {            readInfo.add(this.readInfo.get(i));        }        return readInfo;    }    @Override    // 该实现类中，数据集合中未保存列头，因此直接调用getReadInfoByPage()方法    public List<?> getReadInfoByPageIgnoreHead(int pageSize, int index) {        return getReadInfoByPage(pageSize, index);    }    @Override    // excel总数据量，包括表头的1行数据    public int getRowCount() {        return this.readInfo.size() + 1;    }    private int getMaxIndexFromAnnotationList(List<ExcelField> fieldList) {        int max = 0;        for (ExcelField field : fieldList) {            if (field.index() > max) {                max = field.index();            }        }        return max;    }}